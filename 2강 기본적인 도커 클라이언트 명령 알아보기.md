### 도커 이미지 내부 파일 구조 보기

🎬 docker run alpine ls 실행시 흐름

1.  Alpine 이미지를 이용해서 컨테이너를 생성.

2.  생성 할때 Alpine 이미지 안에 들어있던 파일 스냅샷들이 컨테이너 안에 있는 하드디스크로 다운로드됨.

3.  이미지 이름 뒤에 다른 명령어를 더 붙여서 원래 이미지 안에 들어있는 기본 커멘드는 무시가 되고 ls 명령어가 실행됨.

🤷‍♂️ 그러나 docker run hello-world ls하면 오류가 발생

=> 설명을 보면  executable file not found(실행할 수 있는 파일을 못 찾음)

🤦‍♀️ 그렇다면 어떻게 Alpine 이미지를 이용해 ls 명령어를 실행가능?

=> Alpine 이미지 파일 스냅샷안에 이미 ls를 사용 가능하게 하는 파일이 있음.


### 컨테이너들 나열하기

💻 실습

1. 2개의 Terminal을 작동시킨다

2. 첫번째 Terminal에서 container 하나를 실행(하지만 이때 컨테이너를 켰다가 바로 끄면 3번을 할 때 이미 프로세스가 꺼져 있어 리스트에서 볼 수 없다 ) 

3.  그리고 두번째 Terminal에서 `docker ps` 로 확인

4.  그렇다면 꺼져있는 container도 확인하고 싶다면?
   
     `docker ps -a`

📝 이미지 설명

1.  CONTAINER : 컨테이너의 고유한 아이디 해쉬값. 
   
    실제로는 더욱 길지만 일부분만 표출

2.  IMAGE : 컨테이너 생성 시 사용한 도커 이미지

3.  COMMAND : 컨테이너 시작 시 실행될 명령어. 
   
    대부분 이미지에 내장되어 있으므로 별도 설정이 필요❌

4.  CREATED : 컨테이너가 생성된 시간

5.  STATUS : 컨테이너의 상태. 
   
    실행 중은 Up, 종료는 Exited, 일시정지는 Pause

6.  PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트.
     
    특별한 설정을 하지 않는 경우 출력되지 않는다. 

7.  NAMES : 컨테이너 고유한 이름. 
    
    컨테이너 생성시 --name 옵션으로 이름을 설정하지 않으면 도커 엔진이 임의로 형용사와 명사를 조합해 설정.
   
    id와 마찬가지로 중복은 허용이 않되고 docker rename 명령어로 이름을 변경할 수 있다.

    `docker rename original-name changed-name`


### 도커 컨테이너의 생명주기

📝생명주기

생성(Create) => 시작(Start) => 실행(Running) => 중지(Stopped) => 삭제(Deleted)


📌 생성 => 시작 => 실행 주기

 `docker run <이미지 이름>` = `docker create <이미지 이름> + docker start <컨테이너 아이디/이름>`

😎 Docker create <이미지 이름>

-   이미지에 있는 파일 스냅샷을 도커 컨테이너 안의 하드 디스크에 넣어준다

😊 Docker start <컨테이너 이름/아이디>

-   이미지에 있는 시작 시 실행 될 명령어를 컨테이너에 넣어 컨테너가 실행된다.

`docker start -a(attach) <컨테이너 이름/아이디>` => -a의 역할 : 도커 컨테이너가 실행이 될 때 output을 화면에 표출해주는 역할을 한다.  

### Docker Stop vs Docker Kill

📌도커의 생명주기 중에서 중지 부분은 docker stop과 docker kill로 중지할 수 있다.

1.  docker stop <중지할 컨테이너 이름/아이디>

2.   docker kill <중지할 컨테이너 이름/아이디>

🤷‍♀️ stop과 kill의 차이점은?

공통점은 둘다 실행중인 컨테이너를 중지시킨다.

하지만

1.  `Stop`은 Gracefully하게 중지를 시킨다
    
    자비롭게 그동안 하던 작업들을(메시지를 보내고 있었다면 보내고 있던 메시지) 완료하고 컨테이너를 중지 시킨다.

2.  `Kill` 같은 경우는 `Stop`과 달리 어떠한 것도 기다리지 않고 바로 컨테이너를 중지 시킨다.

### 컨테이너 삭제하기

도커의 생명주기 중에서 삭제 부분

실행 => 중지 => 삭제

🙋‍♂️ 중지된 컨테이너를 삭제하고 싶다면?

`docker rm <컨테이너 아이디/이름>`

`실행중인 컨테이너는 먼저 중지한 후에 삭제 가능.`

🙋‍♀️ 모든 컨테이너를 삭제하고 싶다면?

`docker rm $(docker ps -a -q)`

🙋‍♂️ 이미지를 삭제하고 싶다면?

`docker rmi <이미지 id>`

🙋‍♀️ 모든 이미지를 삭제하고 싶다면?

`docker rmi $(docker images -q) `

🙋‍♂️ 한번에 컨테이너, 이미지, 네트워크를 모두 삭제하고 싶다면?

`docker system prune`

`도커를 쓰지 않을 때 모두 정리하고 싶을 때 사용하면 좋음`

` 하지만 이것도 실행중인 컨테이너에는 영향을 주지 않음`

### 실행중인 컨테이너에 명령어 전달

🤷‍♂️ 이미 실행중인 컨테이너에 명령어를 전달하고 싶다면?

`docker exec <컨테이너 아이디>`

💻 실습하기

1.  먼저 터미널 2개를 실행한다.

2.  첫번째 터미널에서 컨테이너 하나를 실행한다.(docker run alpine ping localhost)

3. 두번째 터미널에서 컨테이너가 잘 작동하고 있는지 확인하고 다른 명령어를 전달한다.  

    ex) docker exec <컨테이너 아이디> ls

✨ docker run vs docker exec

1.  docker run은 `새로 컨테이너`를 만들어서 실행.

2.  docker exec은 이미 `실행중인 컨테이너`에 명령어를 전달

### 레디스를 이용한 컨테이너 이해

🎓 레디스를 도커환경에서 실행을 해서 컨테이너를 더욱 이해해보자

그러기 위해서 레디스를 어떻게 이용하며 작동하는지 알아보자

✔ 작동 흐름

`레디스 서버`가 먼저 작동하고 있어야함 => 그 후 `레디스 클라이언트` 실행 후 명령어를 레디스 서버에 전달.

즉, 레디스 서버를 실행 한 후, 레디스 클라이언트를 통해서 서버에 명령어를 전달해 줘야 한다.

✔ 순서

1. 먼저 첫번째 터미널을 실행 후, 레디스 서버를 작동.
    
    `docker run redis`

2.  그 후, 레디스 클라이언트를 켜야 하는데 첫번째 터미널에서는 아무것도 할 수 없다.
   
    그러니 두번째 터미널을 켜서 레디스 클라이언트를     작동시킨다.

    ` redis-cli`

3.  그러나 에러 발생... 무엇이 잘못 되었을까?
   

=> 레디스 클라이언트가 레디스 서버가 있는 컨테이너 밖에서 실행을 하려 하니 레디스 서버에 접근을 할 수 없기에 레디스 클라이언트를 작동하려 할 때 에러가 발생한다.

그러면 어떻게 해야 할까⁉

📌 레디스 클라이언트도 컨테이너 안에서 실행을 시켜야 한다

✔ 순서

1. 먼저 이전과 똑같이 첫번째 터미널을 킨 후, 레디스 서버를 작동 시킨다.
   
   `docker run redis`

2.  이전에 이전 시간에 배운 exec을 사용할 차례이다.
    
    이미 실행 중인 컨테이너에 명령어를 전달할 때 exec를 쓴다고 배웠다.

    그러니 redis 서버가 실행중인 컨테이너에 exec을 이용하여 redis 클라이언트도 실행한다.

    `docker exec -it <컨테이너 아이디> redis-cli`

    `-it를 붙여줘야 명령어를 실행한 후 계속 명령어를 적을 수 있다 `

    `-i interactive(상호적인), -t terminal `

    `-it가 없다면 redis-cli를 키기만 하고 밖으로 다시 나와버린다`

### 실행중인 컨테이너에서 터미널 생활 즐기기

🎓 지금까지 실행중인 컨테이너에 명령어를 전달할 때는 예를 들어 `docker exec -it <컨테이너 아이디> 명령어`와 같은 식으로 명령어 하나 입력할 때마다 이 모든 것을 계속 입력해줘야했다.

이러한 문제점을 해결해주기 위해 컨테이너 안에 쉘이나 터미널 환경으로 접속을 해줄 수 있다.

그 방법은 마지막 명령어를 `sh`로 주면 된다

`docker exec -it <컨테이너 아이디> sh`

💻 컨테이너를 쉘 환경으로 접근해보기

1. 먼저 첫 번째 터미널을 실행 한 후, alpine 이미지를 이용해서 컨테이너를 실행한다.
    
    `docker run alpine ping localhost`

2. 그 후 exec을 이용해 마지막 명령어 부분에 sh를 입력 후 컨테이너 안에서 터미널 환경을 구축

    `docker exec -it <컨테이너 아이디> sh`

3.  그 안에서 여러가지 터미널에서 원래 할 수 있는 작동들을 해본다.
   
    ex)
    
    -ls - 컨테이너 디렉토리에 있는 내용(디렉토리, 파일) 확인

    -touch new-file - 파일 생성

    -export hello=hi echo $hello - 변수 생성 출력

✔ 이 터미널 환경에서 나오려면 Ctrl + D 

